import {info} from '@actions/core'

/**
 * Reasons why a file might be skipped from AI review
 */
export enum SkipReason {
  GENERATED_FILE = 'generated file',
  TRIVIAL_CHANGE = 'trivial change (formatting/whitespace only)',
  BUILD_ARTIFACT = 'build artifact',
  LOCKFILE = 'lockfile',
  CUSTOM_PATTERN = 'custom skip pattern',
  LARGE_GENERATED = 'large generated file',
  VENDOR_CODE = 'vendor/third-party code',
  TEST_SNAPSHOT = 'test snapshot'
}

/**
 * Result of evaluating whether a file should be skipped
 */
export interface SkipEvaluation {
  shouldSkip: boolean
  reason?: SkipReason
  confidence: number // 0-1, how confident we are in this decision
}

/**
 * Configuration for smart skipping logic
 */
export interface SkipConfig {
  skipGeneratedFiles: boolean
  skipTrivialChanges: boolean
  skipBuildArtifacts: boolean
  skipLockfiles: boolean
  skipVendorCode: boolean
  skipTestSnapshots: boolean
  customSkipPatterns: string[]
  minChangedLinesForReview: number
}

/**
 * Default skip configuration
 */
export const DEFAULT_SKIP_CONFIG: SkipConfig = {
  skipGeneratedFiles: true,
  skipTrivialChanges: true,
  skipBuildArtifacts: true,
  skipLockfiles: true,
  skipVendorCode: true,
  skipTestSnapshots: true,
  customSkipPatterns: [],
  minChangedLinesForReview: 3
}

/**
 * Patterns for common generated files
 */
const GENERATED_FILE_PATTERNS = [
  /package-lock\.json$/,
  /yarn\.lock$/,
  /pnpm-lock\.yaml$/,
  /Gemfile\.lock$/,
  /Cargo\.lock$/,
  /composer\.lock$/,
  /poetry\.lock$/,
  /\.min\.(js|css)$/,
  /\.bundle\.(js|css)$/,
  /-compiled\.(js|css)$/,
  /\.generated\.(ts|js|go|py|java)$/,
  /\.pb\.(go|py)$/, // Protocol buffers
  /\.proto\.go$/,
  /\.pb\.h$/,
  /\.pb\.cc$/,
  /_pb2\.py$/,
  /\.g\.(dart|go)$/,
  /\.freezed\.dart$/,
  /\.gr\.dart$/,
  /\.gen\.(ts|js|dart|swift)$/,
  /codegen\.ts$/,
  /schema\.graphql\.ts$/
]

/**
 * Patterns for build artifacts
 */
const BUILD_ARTIFACT_PATTERNS = [
  /^dist\//,
  /^build\//,
  /^out\//,
  /^target\//,
  /^\.next\//,
  /^\.nuxt\//,
  /^\.output\//,
  /^\.cache\//,
  /^coverage\//,
  /^\.pytest_cache\//,
  /^__pycache__\//,
  /^\.venv\//,
  /^node_modules\//,
  /^\.dart_tool\//,
  /^\.bundle\//
]

/**
 * Patterns for vendor/third-party code
 */
const VENDOR_PATTERNS = [
  /^vendor\//,
  /^third[_-]party\//,
  /^external\//,
  /^libs?\//,
  /^dependencies\//,
  /^packages\//
]

/**
 * Patterns for test snapshots
 */
const TEST_SNAPSHOT_PATTERNS = [
  /\.snap$/,
  /__snapshots__\//,
  /\.snapshot$/,
  /\.test\.ts\.snap$/,
  /\.spec\.ts\.snap$/
]

/**
 * Common file header markers for generated files
 */
const GENERATED_FILE_MARKERS = [
  '// Code generated by',
  '// Code generated DO NOT EDIT',
  '// AUTO-GENERATED',
  '// AUTOGENERATED',
  '// This file is automatically generated',
  '// This file was generated by',
  '/* AUTO GENERATED FILE',
  '/* GENERATED FILE',
  '# Generated by',
  '# Code generated by',
  '# AUTO-GENERATED',
  '# autogenerated',
  '// <auto-generated',
  '// @generated',
  '@generated',
  '/* @generated */'
]

/**
 * Analyzes a file path and diff to determine if it should be skipped
 */
export class SkipAnalyzer {
  constructor(private readonly config: SkipConfig = DEFAULT_SKIP_CONFIG) {}

  /**
   * Evaluate whether a file should be skipped from AI review
   */
  evaluateFile(
    filename: string,
    fileDiff: string,
    fileContent?: string
  ): SkipEvaluation {
    const isLockfile = this.isLockfile(filename)
    const isBuildArtifact = this.isBuildArtifact(filename)
    const isVendorCode = this.isVendorCode(filename)
    const isTestSnapshot = this.isTestSnapshot(filename)

    // Check lockfiles first (highest priority)
    if (isLockfile) {
      if (this.config.skipLockfiles) {
        return {
          shouldSkip: true,
          reason: SkipReason.LOCKFILE,
          confidence: 1.0
        }
      }
      // If skipLockfiles is false, explicitly don't skip (don't fall through to other checks)
      return {
        shouldSkip: false,
        confidence: 1.0
      }
    }

    // Check build artifacts
    if (isBuildArtifact) {
      if (this.config.skipBuildArtifacts) {
        return {
          shouldSkip: true,
          reason: SkipReason.BUILD_ARTIFACT,
          confidence: 1.0
        }
      }
      // If skipBuildArtifacts is false, explicitly don't skip
      return {
        shouldSkip: false,
        confidence: 1.0
      }
    }

    // Check vendor code
    if (isVendorCode) {
      if (this.config.skipVendorCode) {
        return {
          shouldSkip: true,
          reason: SkipReason.VENDOR_CODE,
          confidence: 0.95
        }
      }
      // If skipVendorCode is false, explicitly don't skip
      return {
        shouldSkip: false,
        confidence: 1.0
      }
    }

    // Check test snapshots
    if (isTestSnapshot) {
      if (this.config.skipTestSnapshots) {
        return {
          shouldSkip: true,
          reason: SkipReason.TEST_SNAPSHOT,
          confidence: 0.95
        }
      }
      // If skipTestSnapshots is false, explicitly don't skip
      return {
        shouldSkip: false,
        confidence: 1.0
      }
    }

    // Check custom skip patterns
    if (this.matchesCustomPattern(filename)) {
      return {
        shouldSkip: true,
        reason: SkipReason.CUSTOM_PATTERN,
        confidence: 1.0
      }
    }

    // Check generated files (requires content analysis)
    if (this.config.skipGeneratedFiles) {
      const generatedCheck = this.isGeneratedFile(filename, fileContent)
      if (generatedCheck.isGenerated) {
        return {
          shouldSkip: true,
          reason: SkipReason.GENERATED_FILE,
          confidence: generatedCheck.confidence
        }
      }
    }

    // Check trivial changes (requires diff analysis)
    if (this.config.skipTrivialChanges && fileDiff) {
      const trivialCheck = this.isTrivialChange(fileDiff)
      if (trivialCheck.isTrivial) {
        return {
          shouldSkip: true,
          reason: SkipReason.TRIVIAL_CHANGE,
          confidence: trivialCheck.confidence
        }
      }
    }

    // Default: don't skip
    return {
      shouldSkip: false,
      confidence: 1.0
    }
  }

  /**
   * Check if file is a lockfile
   */
  private isLockfile(filename: string): boolean {
    const lockfilePatterns = [
      'package-lock.json',
      'yarn.lock',
      'pnpm-lock.yaml',
      'Gemfile.lock',
      'Cargo.lock',
      'composer.lock',
      'poetry.lock',
      'Pipfile.lock',
      'go.sum',
      'mix.lock'
    ]

    const basename = filename.split('/').pop() || ''
    return lockfilePatterns.includes(basename)
  }

  /**
   * Check if file is a build artifact
   */
  private isBuildArtifact(filename: string): boolean {
    return BUILD_ARTIFACT_PATTERNS.some(pattern => pattern.test(filename))
  }

  /**
   * Check if file is vendor/third-party code
   */
  private isVendorCode(filename: string): boolean {
    return VENDOR_PATTERNS.some(pattern => pattern.test(filename))
  }

  /**
   * Check if file is a test snapshot
   */
  private isTestSnapshot(filename: string): boolean {
    return TEST_SNAPSHOT_PATTERNS.some(pattern => pattern.test(filename))
  }

  /**
   * Check if filename matches custom skip patterns
   */
  private matchesCustomPattern(filename: string): boolean {
    return this.config.customSkipPatterns.some(pattern => {
      try {
        const regex = new RegExp(pattern)
        return regex.test(filename)
      } catch {
        // Invalid regex, treat as literal string match
        return filename.includes(pattern)
      }
    })
  }

  /**
   * Check if file is generated based on filename and content
   */
  private isGeneratedFile(
    filename: string,
    content?: string
  ): {isGenerated: boolean; confidence: number} {
    // Check filename patterns
    const matchesPattern = GENERATED_FILE_PATTERNS.some(pattern =>
      pattern.test(filename)
    )

    if (matchesPattern) {
      return {isGenerated: true, confidence: 0.95}
    }

    // Check content for generation markers
    if (content) {
      const firstLines = content.split('\n').slice(0, 20).join('\n')
      const hasGenerationMarker = GENERATED_FILE_MARKERS.some(marker =>
        firstLines.includes(marker)
      )

      if (hasGenerationMarker) {
        return {isGenerated: true, confidence: 0.99}
      }
    }

    return {isGenerated: false, confidence: 1.0}
  }

  /**
   * Analyze diff to determine if changes are trivial (formatting, whitespace, comments only)
   */
  private isTrivialChange(diff: string): {
    isTrivial: boolean
    confidence: number
  } {
    // Check if diff looks like a valid diff (contains +++ or --- markers)
    if (!diff.includes('+++') && !diff.includes('---')) {
      // Not a valid diff format, don't treat as trivial
      return {isTrivial: false, confidence: 1.0}
    }

    const lines = diff.split('\n')
    const changedLines = lines.filter(
      line =>
        (line.startsWith('+') || line.startsWith('-')) &&
        !line.startsWith('+++') &&
        !line.startsWith('---')
    )

    if (changedLines.length === 0) {
      // No actual changes, don't treat as trivial (could be binary file or error)
      return {isTrivial: false, confidence: 1.0}
    }

    // Analyze the nature of changes
    const {hasCodeChanges, hasWhitespaceOnly, hasCommentsOnly} =
      this.analyzeChangeTypes(changedLines)

    // Whitespace-only changes are always trivial (regardless of line count)
    if (hasWhitespaceOnly) {
      return {isTrivial: true, confidence: 0.95}
    }

    // Comment-only changes are always trivial (regardless of line count)
    if (hasCommentsOnly) {
      return {isTrivial: true, confidence: 0.85}
    }

    // If there are code changes, check if they meet the minimum threshold
    if (hasCodeChanges) {
      if (changedLines.length < this.config.minChangedLinesForReview) {
        return {isTrivial: true, confidence: 0.8}
      }
    }

    return {isTrivial: false, confidence: 1.0}
  }

  /**
   * Analyze types of changes in the diff
   */
  private analyzeChangeTypes(lines: string[]): {
    hasCodeChanges: boolean
    hasWhitespaceOnly: boolean
    hasCommentsOnly: boolean
  } {
    let hasCodeChanges = false
    let hasWhitespaceOnly = true
    let hasCommentsOnly = true

    for (const line of lines) {
      // Remove the +/- prefix
      const content = line.slice(1)

      // Check if line is only whitespace
      if (content.trim().length > 0) {
        hasWhitespaceOnly = false

        // Check if line is a comment
        const trimmed = content.trim()
        const isComment =
          trimmed.startsWith('//') ||
          trimmed.startsWith('/*') ||
          trimmed.startsWith('*') ||
          trimmed.startsWith('#') ||
          trimmed.startsWith('<!--')

        if (!isComment) {
          hasCommentsOnly = false
          hasCodeChanges = true
        }
      }
    }

    return {hasCodeChanges, hasWhitespaceOnly, hasCommentsOnly}
  }

  /**
   * Log skip decision
   */
  logSkip(filename: string, evaluation: SkipEvaluation): void {
    if (evaluation.shouldSkip) {
      info(
        `⏭️  Skipping ${filename}: ${evaluation.reason} (confidence: ${(
          evaluation.confidence * 100
        ).toFixed(0)}%)`
      )
    }
  }
}

/**
 * Create a skip analyzer with custom configuration
 */
export function createSkipAnalyzer(config?: Partial<SkipConfig>): SkipAnalyzer {
  const fullConfig = {...DEFAULT_SKIP_CONFIG, ...config}
  return new SkipAnalyzer(fullConfig)
}
